// Generated by Claude Sonnet
// Assisted by https://github.com/tintoser

import time

#flag -luser32
#flag -lkernel32
#flag windows -mwindows

// Windows API Constants for SetThreadExecutionState
const es_system_required = u32(0x00000001)
const es_display_required = u32(0x00000002)
const es_continuous = u32(0x80000000)

@[C]
struct POINT {
    x i32
    y i32
}

@[C]
struct INPUT {
mut:
    type_  u32
    union_ [32]byte
}

@[C]
struct KEYBDINPUT {
    w_vk          u16
    w_scan        u16
    dw_flags      u32
    time          u32
    dw_extra_info voidptr
}

// Windows API Functions
fn C.SetCursorPos(x int, y int) bool
fn C.GetCursorPos(lpPoint &POINT) bool
fn C.Sleep(dwMilliseconds u32)
fn C.SetThreadExecutionState(esFlags u32) u32
fn C.SendInput(cInputs u32, pInputs &INPUT, cbSize int) u32

// Constants for input simulation
const input_keyboard = 1
const keyeventf_keyup = 0x0002
const vk_f15 = 0x7E
const interval_seconds = 10
const move_pixels = 30
const idle_threshold_seconds = 60
const max_screen_coord = 65535
const max_retry_attempts = 3
const retry_delay_ms = 100

struct IdleDetector {
mut:
    last_pos POINT
    last_check_time i64
    error_count int
}

fn is_valid_cursor_pos(pos POINT) bool {
    return pos.x >= 0 && pos.x <= max_screen_coord && 
           pos.y >= 0 && pos.y <= max_screen_coord
}

fn (mut d IdleDetector) is_system_idle() bool {
    mut current_pos := POINT{}
    mut retry_count := 0

    for retry_count < max_retry_attempts {
        if C.GetCursorPos(&current_pos) {
            if !is_valid_cursor_pos(current_pos) {
                retry_count++
                C.Sleep(retry_delay_ms)
                continue
            }

            d.error_count = 0 // Reset error counter on success
            current_time := time.now().unix()
            
            if current_pos.x == d.last_pos.x && current_pos.y == d.last_pos.y {
                if current_time - d.last_check_time >= idle_threshold_seconds {
                    return true
                }
            } else {
                d.last_pos = current_pos
                d.last_check_time = current_time
            }
            return false
        }
        retry_count++
        C.Sleep(retry_delay_ms)
    }

    d.error_count++
    return false
}

fn prevent_idle_with_execution_state() bool {
    mut retry_count := 0
    for retry_count < max_retry_attempts {
        if C.SetThreadExecutionState(es_system_required | es_display_required) != 0 {
            return true
        }
        retry_count++
        C.Sleep(retry_delay_ms)
    }
    return false
}

fn simulate_keypress() bool {
    mut inputs := []INPUT{len: 2, init: INPUT{}}
    mut retry_count := 0
    
    unsafe {
        inputs[0].type_ = input_keyboard
        kbd_down := KEYBDINPUT{
            w_vk: vk_f15
            w_scan: 0
            dw_flags: 0
            time: 0
            dw_extra_info: 0
        }
        vmemcpy(&inputs[0].union_, &kbd_down, sizeof(KEYBDINPUT))

        inputs[1].type_ = input_keyboard
        kbd_up := KEYBDINPUT{
            w_vk: vk_f15
            w_scan: 0
            dw_flags: keyeventf_keyup
            time: 0
            dw_extra_info: 0
        }
        vmemcpy(&inputs[1].union_, &kbd_up, sizeof(KEYBDINPUT))

        for retry_count < max_retry_attempts {
            if C.SendInput(2, &inputs[0], sizeof(INPUT)) == 2 {
                return true
            }
            retry_count++
            C.Sleep(retry_delay_ms)
        }
    }
    return false
}

fn move_mouse() bool {
    mut pt := POINT{}
    mut retry_count := 0
    mut success := false

    for retry_count < max_retry_attempts {
        if C.GetCursorPos(&pt) {
            if !is_valid_cursor_pos(pt) {
                retry_count++
                C.Sleep(retry_delay_ms)
                continue
            }

            original_x := pt.x
            original_y := pt.y

            positions := [
                [pt.x + move_pixels, pt.y],
                [pt.x + move_pixels, pt.y + move_pixels],
                [pt.x, pt.y + move_pixels],
                [pt.x, pt.y]
            ]

            // Verify all positions are valid
            mut all_positions_valid := true
            for pos in positions {
                if !is_valid_cursor_pos(POINT{x: pos[0], y: pos[1]}) {
                    all_positions_valid = false
                    break
                }
            }

            if !all_positions_valid {
                return false
            }

            // Perform the movement
            success = true
            for pos in positions {
                if !C.SetCursorPos(int(pos[0]), int(pos[1])) {
                    success = false
                    break
                }
                C.Sleep(50)
            }

            if success {
                // Return to original position
                if C.SetCursorPos(original_x, original_y) {
                    return true
                }
            }
        }
        retry_count++
        C.Sleep(retry_delay_ms)
    }
    return false
}

fn main() {
    // Initial setup with retry
    mut retry_count := 0
    for retry_count < max_retry_attempts {
        if C.SetThreadExecutionState(es_continuous | es_system_required | es_display_required) != 0 {
            break
        }
        retry_count++
        C.Sleep(retry_delay_ms)
    }

    mut detector := IdleDetector{
        last_check_time: time.now().unix()
        error_count: 0
    }
    
    if !C.GetCursorPos(&detector.last_pos) {
        // Initialize with 0,0 if initial get fails
        detector.last_pos = POINT{0, 0}
    }

    mut counter := 0
    for {
        if detector.is_system_idle() {
            match counter % 3 {
                0 { move_mouse() }
                1 { simulate_keypress() }
                2 { prevent_idle_with_execution_state() }
                else {}
            }
            counter++
        }
        time.sleep(interval_seconds * time.second)
    }
}